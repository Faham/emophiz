// Created by Microsoft (R) C/C++ Compiler Version 12.00.9782.0 (31e1bcf0).
//
// TTLLiveCtrl.tli
//
// Wrapper implementations for Win32 type library ..\..\..\..\TTLLiveCtrl.dll
// compiler-generated file created 03/29/06 at 19:20:14 - DO NOT EDIT!

#pragma once

//
// interface ITTLLiveText wrapper method implementations
//

inline _bstr_t ITTLLiveText::GetPhysicalChannelText ( enum TTLAPI_CHANNELS eValue ) {
    BSTR _result;
    HRESULT _hr = raw_GetPhysicalChannelText(eValue, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline _bstr_t ITTLLiveText::GetRecordingModeText ( enum TTLAPI_RECORDING_MODES eValue ) {
    BSTR _result;
    HRESULT _hr = raw_GetRecordingModeText(eValue, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline _bstr_t ITTLLiveText::GetSensorTypeText ( enum TTLAPI_SENSOR_TYPES eValue ) {
    BSTR _result;
    HRESULT _hr = raw_GetSensorTypeText(eValue, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline _bstr_t ITTLLiveText::GetEncoderModelTypeText ( enum TTLAPI_ENCODER_MODEL_TYPES eValue ) {
    BSTR _result;
    HRESULT _hr = raw_GetEncoderModelTypeText(eValue, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline _bstr_t ITTLLiveText::GetSensorStateText ( enum TTLAPI_SENSOR_STATES eValue ) {
    BSTR _result;
    HRESULT _hr = raw_GetSensorStateText(eValue, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline _bstr_t ITTLLiveText::GetSynchronizationStateText ( enum TTLAPI_SYNC_STATES eValue ) {
    BSTR _result;
    HRESULT _hr = raw_GetSynchronizationStateText(eValue, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline _bstr_t ITTLLiveText::GetImpedanceCheckResultText ( enum TTLAPI_IMPCHECK_RESULTS eValue ) {
    BSTR _result;
    HRESULT _hr = raw_GetImpedanceCheckResultText(eValue, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline _bstr_t ITTLLiveText::GetDecryptionStateText ( enum TTLAPI_DECRYPTION_STATES eValue ) {
    BSTR _result;
    HRESULT _hr = raw_GetDecryptionStateText(eValue, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline _bstr_t ITTLLiveText::GetEncoderStateText ( enum TTLAPI_ENCODER_STATES eValue ) {
    BSTR _result;
    HRESULT _hr = raw_GetEncoderStateText(eValue, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline _bstr_t ITTLLiveText::GetConnectionTypeText ( enum TTLAPI_CONNECTION_TYPES eValue ) {
    BSTR _result;
    HRESULT _hr = raw_GetConnectionTypeText(eValue, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline _bstr_t ITTLLiveText::GetProtocolTypeText ( enum TTLAPI_PROTOCOL_TYPES eValue ) {
    BSTR _result;
    HRESULT _hr = raw_GetProtocolTypeText(eValue, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline _bstr_t ITTLLiveText::GetUnitTypeText ( enum TTLAPI_UNIT_TYPES eValue ) {
    BSTR _result;
    HRESULT _hr = raw_GetUnitTypeText(eValue, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline _bstr_t ITTLLiveText::GetPlaybackModeText ( enum TTLAPI_PLAYBACK_MODES eValue ) {
    BSTR _result;
    HRESULT _hr = raw_GetPlaybackModeText(eValue, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline _bstr_t ITTLLiveText::GetEventTypeText ( enum TTLAPI_EVENT_TYPES eValue ) {
    BSTR _result;
    HRESULT _hr = raw_GetEventTypeText(eValue, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline _bstr_t ITTLLiveText::GetEventHorizonText ( enum TTLAPI_EVENT_HORIZON_MODES eValue ) {
    BSTR _result;
    HRESULT _hr = raw_GetEventHorizonText(eValue, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline _bstr_t ITTLLiveText::GetConnectionCommandText ( enum TTLAPI_OPENCONNECTIONS_CMD_BITS eValue ) {
    BSTR _result;
    HRESULT _hr = raw_GetConnectionCommandText(eValue, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline _bstr_t ITTLLiveText::GetNotificationActiveBitText ( enum TTLAPI_NOTIFICATION_ACTIVE_BITS eValue ) {
    BSTR _result;
    HRESULT _hr = raw_GetNotificationActiveBitText(eValue, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline _bstr_t ITTLLiveText::GetNotificationMessageText ( enum TTLAPI_NOTIFICATION_MESSAGES eValue ) {
    BSTR _result;
    HRESULT _hr = raw_GetNotificationMessageText(eValue, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline _bstr_t ITTLLiveText::GetImpCheckCalculationTypeText ( enum TTLAPI_IMPCHECK_CALCULATION_TYPES eValue ) {
    BSTR _result;
    HRESULT _hr = raw_GetImpCheckCalculationTypeText(eValue, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

//
// dispinterface _ITTLLiveEvents wrapper method implementations
//

inline HRESULT _ITTLLiveEvents::ChannelData ( long liChannelHND, long liSamplesCount ) {
    HRESULT _result;
    _com_dispatch_method(this, 0x1, DISPATCH_METHOD, VT_ERROR, (void*)&_result, 
        L"\x0003\x0003", liChannelHND, liSamplesCount);
    return _result;
}

inline HRESULT _ITTLLiveEvents::EventSwitch ( long liEncoderHND, long liTickCount ) {
    HRESULT _result;
    _com_dispatch_method(this, 0x2, DISPATCH_METHOD, VT_ERROR, (void*)&_result, 
        L"\x0003\x0003", liEncoderHND, liTickCount);
    return _result;
}

inline HRESULT _ITTLLiveEvents::SensorStateChange ( long liChannelHND, long liNewState ) {
    HRESULT _result;
    _com_dispatch_method(this, 0x3, DISPATCH_METHOD, VT_ERROR, (void*)&_result, 
        L"\x0003\x0003", liChannelHND, liNewState);
    return _result;
}

inline HRESULT _ITTLLiveEvents::EncoderStateChange ( long liEncoderHND, long liNewState ) {
    HRESULT _result;
    _com_dispatch_method(this, 0x4, DISPATCH_METHOD, VT_ERROR, (void*)&_result, 
        L"\x0003\x0003", liEncoderHND, liNewState);
    return _result;
}

inline HRESULT _ITTLLiveEvents::DataOverflow ( long liChannelHND, long liReserved ) {
    HRESULT _result;
    _com_dispatch_method(this, 0x5, DISPATCH_METHOD, VT_ERROR, (void*)&_result, 
        L"\x0003\x0003", liChannelHND, liReserved);
    return _result;
}

inline HRESULT _ITTLLiveEvents::DataError ( long liEncoderHND, long liReserved ) {
    HRESULT _result;
    _com_dispatch_method(this, 0x6, DISPATCH_METHOD, VT_ERROR, (void*)&_result, 
        L"\x0003\x0003", liEncoderHND, liReserved);
    return _result;
}

inline HRESULT _ITTLLiveEvents::DataTimeOut ( long liEncoderHND ) {
    HRESULT _result;
    _com_dispatch_method(this, 0x7, DISPATCH_METHOD, VT_ERROR, (void*)&_result, 
        L"\x0003", liEncoderHND);
    return _result;
}

inline HRESULT _ITTLLiveEvents::ImpCheckResults ( long liChannelHND, long liReserved ) {
    HRESULT _result;
    _com_dispatch_method(this, 0x8, DISPATCH_METHOD, VT_ERROR, (void*)&_result, 
        L"\x0003\x0003", liChannelHND, liReserved);
    return _result;
}

inline HRESULT _ITTLLiveEvents::SyncStateChange ( long liNewState, long liReserved ) {
    HRESULT _result;
    _com_dispatch_method(this, 0x9, DISPATCH_METHOD, VT_ERROR, (void*)&_result, 
        L"\x0003\x0003", liNewState, liReserved);
    return _result;
}

inline HRESULT _ITTLLiveEvents::EventSwitchOff ( long liEncoderHND, long liTickCount ) {
    HRESULT _result;
    _com_dispatch_method(this, 0xa, DISPATCH_METHOD, VT_ERROR, (void*)&_result, 
        L"\x0003\x0003", liEncoderHND, liTickCount);
    return _result;
}

inline HRESULT _ITTLLiveEvents::DataGap ( long liEncoderHND, long liGapStart, long liGapSize ) {
    HRESULT _result;
    _com_dispatch_method(this, 0xb, DISPATCH_METHOD, VT_ERROR, (void*)&_result, 
        L"\x0003\x0003\x0003", liEncoderHND, liGapStart, liGapSize);
    return _result;
}

inline HRESULT _ITTLLiveEvents::TicksAheadUpdate ( long liEncoderHND ) {
    HRESULT _result;
    _com_dispatch_method(this, 0xc, DISPATCH_METHOD, VT_ERROR, (void*)&_result, 
        L"\x0003", liEncoderHND);
    return _result;
}

inline HRESULT _ITTLLiveEvents::EventOutputFailure ( long liEncoderHND, long bRequestedState ) {
    HRESULT _result;
    _com_dispatch_method(this, 0xd, DISPATCH_METHOD, VT_ERROR, (void*)&_result, 
        L"\x0003\x0003", liEncoderHND, bRequestedState);
    return _result;
}

//
// dispinterface _ITTLLiveInternalEvents wrapper method implementations
//

inline HRESULT _ITTLLiveInternalEvents::ChannelDestroyed ( long liHND ) {
    HRESULT _result;
    _com_dispatch_method(this, 0x1, DISPATCH_METHOD, VT_ERROR, (void*)&_result, 
        L"\x0003", liHND);
    return _result;
}

inline HRESULT _ITTLLiveInternalEvents::EncoderDestroyed ( long liHND ) {
    HRESULT _result;
    _com_dispatch_method(this, 0x2, DISPATCH_METHOD, VT_ERROR, (void*)&_result, 
        L"\x0003", liHND);
    return _result;
}

//
// interface ITTLChannel wrapper method implementations
//

inline float ITTLChannel::GetAutoZero ( ) {
    float _result;
    HRESULT _hr = get_AutoZero(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline void ITTLChannel::PutAutoZero ( float pVal ) {
    HRESULT _hr = put_AutoZero(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline long ITTLChannel::GetActive ( ) {
    long _result;
    HRESULT _hr = get_Active(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline void ITTLChannel::PutActive ( long pVal ) {
    HRESULT _hr = put_Active(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline long ITTLChannel::GetEncoderHND ( ) {
    long _result;
    HRESULT _hr = get_EncoderHND(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline long ITTLChannel::GetPhysicalIndex ( ) {
    long _result;
    HRESULT _hr = get_PhysicalIndex(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline float ITTLChannel::GetNominalSampleRate ( ) {
    float _result;
    HRESULT _hr = get_NominalSampleRate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline long ITTLChannel::GetNotification ( ) {
    long _result;
    HRESULT _hr = get_Notification(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline void ITTLChannel::PutNotification ( long pliNotification ) {
    HRESULT _hr = put_Notification(pliNotification);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline long ITTLChannel::GetSamplesAvailable ( ) {
    long _result;
    HRESULT _hr = get_SamplesAvailable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline long ITTLChannel::GetSensorConnected ( ) {
    long _result;
    HRESULT _hr = get_SensorConnected(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline enum TTLAPI_UNIT_TYPES ITTLChannel::GetUnitType ( ) {
    enum TTLAPI_UNIT_TYPES _result;
    HRESULT _hr = get_UnitType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline void ITTLChannel::PutUnitType ( enum TTLAPI_UNIT_TYPES pVal ) {
    HRESULT _hr = put_UnitType(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline enum TTLAPI_SENSOR_TYPES ITTLChannel::GetSensorID ( ) {
    enum TTLAPI_SENSOR_TYPES _result;
    HRESULT _hr = get_SensorID(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline enum TTLAPI_SENSOR_STATES ITTLChannel::GetSensorState ( ) {
    enum TTLAPI_SENSOR_STATES _result;
    HRESULT _hr = get_SensorState(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline long ITTLChannel::GetForceSensor ( ) {
    long _result;
    HRESULT _hr = get_ForceSensor(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline void ITTLChannel::PutForceSensor ( long pVal ) {
    HRESULT _hr = put_ForceSensor(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline float ITTLChannel::GetOffset ( ) {
    float _result;
    HRESULT _hr = get_Offset(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline void ITTLChannel::PutOffset ( float pVal ) {
    HRESULT _hr = put_Offset(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline enum TTLAPI_SENSOR_TYPES ITTLChannel::GetSensorType ( ) {
    enum TTLAPI_SENSOR_TYPES _result;
    HRESULT _hr = get_SensorType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline void ITTLChannel::PutSensorType ( enum TTLAPI_SENSOR_TYPES pVal ) {
    HRESULT _hr = put_SensorType(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline float ITTLChannel::GetImpCheckAge ( ) {
    float _result;
    HRESULT _hr = get_ImpCheckAge(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline float ITTLChannel::GetImpCheckResults ( enum TTLAPI_IMPCHECK_RESULTS liResultIndex ) {
    float _result;
    HRESULT _hr = get_ImpCheckResults(liResultIndex, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline float ITTLChannel::GetScale ( ) {
    float _result;
    HRESULT _hr = get_Scale(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline void ITTLChannel::PutScale ( float pVal ) {
    HRESULT _hr = put_Scale(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline HRESULT ITTLChannel::Drop ( ) {
    HRESULT _hr = raw_Drop();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline long ITTLChannel::ReadData ( float * pfBuffer, long * pliMaxSamples ) {
    long _result;
    HRESULT _hr = raw_ReadData(pfBuffer, pliMaxSamples, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline _variant_t ITTLChannel::ReadDataVT ( long liMaxSamples ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = raw_ReadDataVT(liMaxSamples, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

inline long ITTLChannel::GetNextSampleTicks ( ) {
    long _result;
    HRESULT _hr = get_NextSampleTicks(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline long ITTLChannel::PeekFirstEvent ( ) {
    long _result;
    HRESULT _hr = raw_PeekFirstEvent(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline long ITTLChannel::PeekNextEvent ( ) {
    long _result;
    HRESULT _hr = raw_PeekNextEvent(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline long ITTLChannel::GetEventHorizon ( enum TTLAPI_EVENT_HORIZON_MODES eMode ) {
    long _result;
    HRESULT _hr = get_EventHorizon(eMode, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline enum TTLAPI_EVENT_TYPES ITTLChannel::GetEventType ( ) {
    enum TTLAPI_EVENT_TYPES _result;
    HRESULT _hr = get_EventType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline long ITTLChannel::GetEventCount ( ) {
    long _result;
    HRESULT _hr = get_EventCount(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline long ITTLChannel::GetEventTicks ( ) {
    long _result;
    HRESULT _hr = get_EventTicks(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline long ITTLChannel::GetEventLength ( ) {
    long _result;
    HRESULT _hr = get_EventLength(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline long ITTLChannel::GetHND ( ) {
    long _result;
    HRESULT _hr = get_HND(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline long ITTLChannel::GetShortReadMask ( ) {
    long _result;
    HRESULT _hr = get_ShortReadMask(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline void ITTLChannel::PutShortReadMask ( long pVal ) {
    HRESULT _hr = put_ShortReadMask(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline long ITTLChannel::GetEventInsertionMask ( ) {
    long _result;
    HRESULT _hr = get_EventInsertionMask(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline void ITTLChannel::PutEventInsertionMask ( long pVal ) {
    HRESULT _hr = put_EventInsertionMask(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline void ITTLChannel::PutEventHorizon ( enum TTLAPI_EVENT_HORIZON_MODES eMode, long pVal ) {
    HRESULT _hr = put_EventHorizon(eMode, pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface ITTLLive wrapper method implementations
//

inline long ITTLLive::GetEncoderCount ( ) {
    long _result;
    HRESULT _hr = get_EncoderCount(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline long ITTLLive::GetChannelCount ( ) {
    long _result;
    HRESULT _hr = get_ChannelCount(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline long ITTLLive::GetVersion ( ) {
    long _result;
    HRESULT _hr = get_Version(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline float ITTLLive::GetBatteryLevelPct ( long liEncoderHND ) {
    float _result;
    HRESULT _hr = get_BatteryLevelPct(liEncoderHND, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline _bstr_t ITTLLive::GetConnectionName ( long liEncoderHND ) {
    BSTR _result;
    HRESULT _hr = get_ConnectionName(liEncoderHND, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline long ITTLLive::GetConnectionType ( long liEncoderHND ) {
    long _result;
    HRESULT _hr = get_ConnectionType(liEncoderHND, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline long ITTLLive::GetEncoderChannelCount ( long liEncoderHND ) {
    long _result;
    HRESULT _hr = get_EncoderChannelCount(liEncoderHND, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline _bstr_t ITTLLive::GetEncoderModelName ( long liEncoderHND ) {
    BSTR _result;
    HRESULT _hr = get_EncoderModelName(liEncoderHND, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline long ITTLLive::GetEncoderModelType ( long liEncoderHND ) {
    long _result;
    HRESULT _hr = get_EncoderModelType(liEncoderHND, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline long ITTLLive::GetFirmwareVersion ( long liEncoderHND ) {
    long _result;
    HRESULT _hr = get_FirmwareVersion(liEncoderHND, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline long ITTLLive::GetHardwareVersion ( long liEncoderHND ) {
    long _result;
    HRESULT _hr = get_HardwareVersion(liEncoderHND, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline long ITTLLive::GetProtocolType ( long liEncoderHND ) {
    long _result;
    HRESULT _hr = get_ProtocolType(liEncoderHND, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline long ITTLLive::GetSensorStatus ( long liEncoderHND ) {
    long _result;
    HRESULT _hr = get_SensorStatus(liEncoderHND, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline _bstr_t ITTLLive::GetSerialNumber ( long liEncoderHND ) {
    BSTR _result;
    HRESULT _hr = get_SerialNumber(liEncoderHND, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline float ITTLLive::GetAutoZero ( long liChannelHND ) {
    float _result;
    HRESULT _hr = get_AutoZero(liChannelHND, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline void ITTLLive::PutAutoZero ( long liChannelHND, float pfSeconds ) {
    HRESULT _hr = put_AutoZero(liChannelHND, pfSeconds);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline long ITTLLive::GetChannelActive ( long liChannelHND ) {
    long _result;
    HRESULT _hr = get_ChannelActive(liChannelHND, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline void ITTLLive::PutChannelActive ( long liChannelHND, long pbActive ) {
    HRESULT _hr = put_ChannelActive(liChannelHND, pbActive);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline long ITTLLive::GetChannelEncoderHND ( long liChannelHND ) {
    long _result;
    HRESULT _hr = get_ChannelEncoderHND(liChannelHND, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline long ITTLLive::GetChannelPhysicalIndex ( long liChannelHND ) {
    long _result;
    HRESULT _hr = get_ChannelPhysicalIndex(liChannelHND, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline float ITTLLive::GetNominalSampleRate ( long liChannelHND ) {
    float _result;
    HRESULT _hr = get_NominalSampleRate(liChannelHND, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline long ITTLLive::GetNotification ( long liChannelHND ) {
    long _result;
    HRESULT _hr = get_Notification(liChannelHND, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline void ITTLLive::PutNotification ( long liChannelHND, long pliNotification ) {
    HRESULT _hr = put_Notification(liChannelHND, pliNotification);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline long ITTLLive::GetSamplesAvailable ( long liChannelHND ) {
    long _result;
    HRESULT _hr = get_SamplesAvailable(liChannelHND, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline long ITTLLive::GetSensorConnected ( long liChannelHND ) {
    long _result;
    HRESULT _hr = get_SensorConnected(liChannelHND, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline long ITTLLive::GetUnitType ( long liChannelHND ) {
    long _result;
    HRESULT _hr = get_UnitType(liChannelHND, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline void ITTLLive::PutUnitType ( long liChannelHND, long pliUnitType ) {
    HRESULT _hr = put_UnitType(liChannelHND, pliUnitType);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline HRESULT ITTLLive::RegisterClientThreadId ( long liThreadHND ) {
    HRESULT _hr = raw_RegisterClientThreadId(liThreadHND);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT ITTLLive::AssignEncoderHND ( _bstr_t bstrSerialNumber, long liNewEncoderHND ) {
    HRESULT _hr = raw_AssignEncoderHND(bstrSerialNumber, liNewEncoderHND);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT ITTLLive::CloseConnection ( long liEncoderHND ) {
    HRESULT _hr = raw_CloseConnection(liEncoderHND);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT ITTLLive::CloseConnections ( ) {
    HRESULT _hr = raw_CloseConnections();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline long ITTLLive::GetFirstEncoderHND ( ) {
    long _result;
    HRESULT _hr = raw_GetFirstEncoderHND(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline long ITTLLive::GetNextEncoderHND ( ) {
    long _result;
    HRESULT _hr = raw_GetNextEncoderHND(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline long ITTLLive::OpenConnection ( _bstr_t bstrDeviceName, long liPollingInterval ) {
    long _result;
    HRESULT _hr = raw_OpenConnection(bstrDeviceName, liPollingInterval, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline HRESULT ITTLLive::OpenConnections ( long libmCommand, long liPollingInterval, long * plibmScanned, long * plibmDetected ) {
    HRESULT _hr = raw_OpenConnections(libmCommand, liPollingInterval, plibmScanned, plibmDetected);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT ITTLLive::AddChannel ( long liEncoderHND, long liPhysicalChannelIndex, long * pliChannelHND ) {
    HRESULT _hr = raw_AddChannel(liEncoderHND, liPhysicalChannelIndex, pliChannelHND);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT ITTLLive::AutoSetupChannels ( ) {
    HRESULT _hr = raw_AutoSetupChannels();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT ITTLLive::DropChannel ( long liChannelHND ) {
    HRESULT _hr = raw_DropChannel(liChannelHND);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT ITTLLive::DropChannels ( ) {
    HRESULT _hr = raw_DropChannels();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline long ITTLLive::GetFirstChannelHND ( ) {
    long _result;
    HRESULT _hr = raw_GetFirstChannelHND(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline long ITTLLive::GetNextChannelHND ( ) {
    long _result;
    HRESULT _hr = raw_GetNextChannelHND(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline long ITTLLive::ReadChannelData ( long liChannelHND, float * pfBuffer, long * pliMaxSamples ) {
    long _result;
    HRESULT _hr = raw_ReadChannelData(liChannelHND, pfBuffer, pliMaxSamples, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline _variant_t ITTLLive::ReadChannelDataVT ( long liChannelHND, long liMaxSamples ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = raw_ReadChannelDataVT(liChannelHND, liMaxSamples, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

inline HRESULT ITTLLive::StartChannels ( ) {
    HRESULT _hr = raw_StartChannels();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT ITTLLive::StopChannels ( ) {
    HRESULT _hr = raw_StopChannels();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline long ITTLLive::GetFirstChannelHND ( long liEncoderHND ) {
    long _result;
    HRESULT _hr = get_FirstChannelHND(liEncoderHND, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline void ITTLLive::PutFirstChannelHND ( long liEncoderHND, long pliFirstChannelHND ) {
    HRESULT _hr = put_FirstChannelHND(liEncoderHND, pliFirstChannelHND);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline long ITTLLive::GetEncoderID ( long liEncoderHND ) {
    long _result;
    HRESULT _hr = get_EncoderID(liEncoderHND, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline long ITTLLive::GetNotificationMask ( ) {
    long _result;
    HRESULT _hr = get_NotificationMask(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline void ITTLLive::PutNotificationMask ( long pliMask ) {
    HRESULT _hr = put_NotificationMask(pliMask);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline long ITTLLive::GetEventInsertionMask ( long liChannelHND ) {
    long _result;
    HRESULT _hr = get_EventInsertionMask(liChannelHND, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline void ITTLLive::PutEventInsertionMask ( long liChannelHND, long pVal ) {
    HRESULT _hr = put_EventInsertionMask(liChannelHND, pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline long ITTLLive::GetSensorID ( long liChannelHND ) {
    long _result;
    HRESULT _hr = get_SensorID(liChannelHND, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline long ITTLLive::GetSensorState ( long liChannelHND ) {
    long _result;
    HRESULT _hr = get_SensorState(liChannelHND, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline long ITTLLive::GetEncoderState ( long liEncoderHND ) {
    long _result;
    HRESULT _hr = get_EncoderState(liEncoderHND, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline long ITTLLive::GetForceSensor ( long liChannelHND ) {
    long _result;
    HRESULT _hr = get_ForceSensor(liChannelHND, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline void ITTLLive::PutForceSensor ( long liChannelHND, long pbForceSensor ) {
    HRESULT _hr = put_ForceSensor(liChannelHND, pbForceSensor);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline float ITTLLive::GetChannelOffset ( long liChannelHND ) {
    float _result;
    HRESULT _hr = get_ChannelOffset(liChannelHND, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline void ITTLLive::PutChannelOffset ( long liChannelHND, float pVal ) {
    HRESULT _hr = put_ChannelOffset(liChannelHND, pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline long ITTLLive::GetSensorType ( long liChannelHND ) {
    long _result;
    HRESULT _hr = get_SensorType(liChannelHND, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline void ITTLLive::PutSensorType ( long liChannelHND, long pliSensorType ) {
    HRESULT _hr = put_SensorType(liChannelHND, pliSensorType);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline long ITTLLive::GetImpCheckType ( ) {
    long _result;
    HRESULT _hr = get_ImpCheckType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline void ITTLLive::PutImpCheckType ( long pliImpCheckType ) {
    HRESULT _hr = put_ImpCheckType(pliImpCheckType);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline float ITTLLive::GetImpCheckAge ( long liChannelHND ) {
    float _result;
    HRESULT _hr = get_ImpCheckAge(liChannelHND, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline float ITTLLive::GetImpCheckResults ( long liChannelHND, long liResultIndex ) {
    float _result;
    HRESULT _hr = get_ImpCheckResults(liChannelHND, liResultIndex, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline HRESULT ITTLLive::StartRecord ( long liEncoderHND, _bstr_t bstrFilename ) {
    HRESULT _hr = raw_StartRecord(liEncoderHND, bstrFilename);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT ITTLLive::StopRecord ( long liEncoderHND ) {
    HRESULT _hr = raw_StopRecord(liEncoderHND);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline DATE ITTLLive::GetEncoderTime ( long liEncoderHND ) {
    DATE _result;
    HRESULT _hr = get_EncoderTime(liEncoderHND, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline DATE ITTLLive::GetEncoderTimeAdjustment ( long liEncoderHND ) {
    DATE _result;
    HRESULT _hr = get_EncoderTimeAdjustment(liEncoderHND, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline long ITTLLive::GetPlaybackMode ( long liEncoderHND ) {
    long _result;
    HRESULT _hr = get_PlaybackMode(liEncoderHND, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline void ITTLLive::PutPlaybackMode ( long liEncoderHND, long pVal ) {
    HRESULT _hr = put_PlaybackMode(liEncoderHND, pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline long ITTLLive::GetPlaybackStart ( long liEncoderHND ) {
    long _result;
    HRESULT _hr = get_PlaybackStart(liEncoderHND, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline void ITTLLive::PutPlaybackStart ( long liEncoderHND, long pVal ) {
    HRESULT _hr = put_PlaybackStart(liEncoderHND, pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline long ITTLLive::GetPlaybackEnd ( long liEncoderHND ) {
    long _result;
    HRESULT _hr = get_PlaybackEnd(liEncoderHND, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline void ITTLLive::PutPlaybackEnd ( long liEncoderHND, long pVal ) {
    HRESULT _hr = put_PlaybackEnd(liEncoderHND, pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline long ITTLLive::GetPlaybackPosition ( long liEncoderHND ) {
    long _result;
    HRESULT _hr = get_PlaybackPosition(liEncoderHND, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline void ITTLLive::PutPlaybackPosition ( long liEncoderHND, long pVal ) {
    HRESULT _hr = put_PlaybackPosition(liEncoderHND, pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline float ITTLLive::GetPlaybackSpeed ( long liEncoderHND ) {
    float _result;
    HRESULT _hr = get_PlaybackSpeed(liEncoderHND, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline void ITTLLive::PutPlaybackSpeed ( long liEncoderHND, float pVal ) {
    HRESULT _hr = put_PlaybackSpeed(liEncoderHND, pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline long ITTLLive::GetSwitchState ( long liEncoderHND ) {
    long _result;
    HRESULT _hr = get_SwitchState(liEncoderHND, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline void ITTLLive::PutSwitchState ( long liEncoderHND, long pVal ) {
    HRESULT _hr = put_SwitchState(liEncoderHND, pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline float ITTLLive::GetBatteryLevelVolt ( long liEncoderHND ) {
    float _result;
    HRESULT _hr = get_BatteryLevelVolt(liEncoderHND, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline float ITTLLive::GetBatteryTimeLeft ( long liEncoderHND ) {
    float _result;
    HRESULT _hr = get_BatteryTimeLeft(liEncoderHND, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline float ITTLLive::GetChannelScale ( long liChannelHND ) {
    float _result;
    HRESULT _hr = get_ChannelScale(liChannelHND, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline void ITTLLive::PutChannelScale ( long liChannelHND, float pVal ) {
    HRESULT _hr = put_ChannelScale(liChannelHND, pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline long ITTLLive::GetEventInputState ( long liEncoderHND ) {
    long _result;
    HRESULT _hr = get_EventInputState(liEncoderHND, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline float ITTLLive::GetTickRate ( long liEncoderHND ) {
    float _result;
    HRESULT _hr = get_TickRate(liEncoderHND, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline long ITTLLive::GetDecryptionState ( long liEncoderHND ) {
    long _result;
    HRESULT _hr = get_DecryptionState(liEncoderHND, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline HRESULT ITTLLive::UnlockDecryption ( long liEncoderHND, long liUnlockValue ) {
    HRESULT _hr = raw_UnlockDecryption(liEncoderHND, liUnlockValue);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline void ITTLLive::PutEncoderModelType ( long liEncoderHND, long pliEncoderModelType ) {
    HRESULT _hr = put_EncoderModelType(liEncoderHND, pliEncoderModelType);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline _bstr_t ITTLLive::GetProtocolName ( long liEncoderHND ) {
    BSTR _result;
    HRESULT _hr = get_ProtocolName(liEncoderHND, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

//
// interface ITTLLive2 wrapper method implementations
//

inline long ITTLLive2::GetGlobalTickRate ( ) {
    long _result;
    HRESULT _hr = get_GlobalTickRate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline long ITTLLive2::GetMasterEncoderHND ( ) {
    long _result;
    HRESULT _hr = get_MasterEncoderHND(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline void ITTLLive2::PutMasterEncoderHND ( long pVal ) {
    HRESULT _hr = put_MasterEncoderHND(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline float ITTLLive2::GetGapFillValue ( ) {
    float _result;
    HRESULT _hr = get_GapFillValue(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline void ITTLLive2::PutGapFillValue ( float pVal ) {
    HRESULT _hr = put_GapFillValue(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline _bstr_t ITTLLive2::GetTTUSB_SN ( long liEncoderHND ) {
    BSTR _result;
    HRESULT _hr = get_TTUSB_SN(liEncoderHND, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline long ITTLLive2::GetTTUSB_FirmwareVersion ( long liEncoderHND ) {
    long _result;
    HRESULT _hr = get_TTUSB_FirmwareVersion(liEncoderHND, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline long ITTLLive2::GetMinTicksAvailable ( ) {
    long _result;
    HRESULT _hr = get_MinTicksAvailable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline long ITTLLive2::GetShortReadMask ( ) {
    long _result;
    HRESULT _hr = get_ShortReadMask(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline void ITTLLive2::PutShortReadMask ( long pVal ) {
    HRESULT _hr = put_ShortReadMask(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline ITTLChannelPtr ITTLLive2::GetChannel ( long liChannelHND ) {
    struct ITTLChannel * _result;
    HRESULT _hr = get_Channel(liChannelHND, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ITTLChannelPtr(_result, false);
}

inline ITTLEncoderPtr ITTLLive2::GetEncoder ( long liEncoderHND ) {
    struct ITTLEncoder * _result;
    HRESULT _hr = get_Encoder(liEncoderHND, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ITTLEncoderPtr(_result, false);
}

inline long ITTLLive2::GetForcedProtocol ( ) {
    long _result;
    HRESULT _hr = get_ForcedProtocol(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline void ITTLLive2::PutForcedProtocol ( long pVal ) {
    HRESULT _hr = put_ForcedProtocol(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline enum TTLAPI_SYNC_STATES ITTLLive2::GetSyncState ( ) {
    enum TTLAPI_SYNC_STATES _result;
    HRESULT _hr = get_SyncState(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline long ITTLLive2::GetGapChannelFill ( ) {
    long _result;
    HRESULT _hr = get_GapChannelFill(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline void ITTLLive2::PutGapChannelFill ( long pVal ) {
    HRESULT _hr = put_GapChannelFill(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline long ITTLLive2::GetGapChannelForceFill ( ) {
    long _result;
    HRESULT _hr = get_GapChannelForceFill(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline void ITTLLive2::PutGapChannelForceFill ( long pVal ) {
    HRESULT _hr = put_GapChannelForceFill(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline long ITTLLive2::GetGapEncoderFill ( ) {
    long _result;
    HRESULT _hr = get_GapEncoderFill(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline void ITTLLive2::PutGapEncoderFill ( long pVal ) {
    HRESULT _hr = put_GapEncoderFill(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline long ITTLLive2::GetGapEncoderOfflineFill ( ) {
    long _result;
    HRESULT _hr = get_GapEncoderOfflineFill(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline void ITTLLive2::PutGapEncoderOfflineFill ( long pVal ) {
    HRESULT _hr = put_GapEncoderOfflineFill(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline long ITTLLive2::GetGapEncoderLateFill ( ) {
    long _result;
    HRESULT _hr = get_GapEncoderLateFill(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline void ITTLLive2::PutGapEncoderLateFill ( long pVal ) {
    HRESULT _hr = put_GapEncoderLateFill(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline long ITTLLive2::GetGapLateFillLatency ( ) {
    long _result;
    HRESULT _hr = get_GapLateFillLatency(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline void ITTLLive2::PutGapLateFillLatency ( long pVal ) {
    HRESULT _hr = put_GapLateFillLatency(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline long ITTLLive2::GetSyncSendTrigger ( ) {
    long _result;
    HRESULT _hr = get_SyncSendTrigger(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline void ITTLLive2::PutSyncSendTrigger ( long pVal ) {
    HRESULT _hr = put_SyncSendTrigger(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline long ITTLLive2::GetSyncWaitTrigger ( ) {
    long _result;
    HRESULT _hr = get_SyncWaitTrigger(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline void ITTLLive2::PutSyncWaitTrigger ( long pVal ) {
    HRESULT _hr = put_SyncWaitTrigger(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline long ITTLLive2::GetSyncSendPeriodic ( ) {
    long _result;
    HRESULT _hr = get_SyncSendPeriodic(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline void ITTLLive2::PutSyncSendPeriodic ( long pVal ) {
    HRESULT _hr = put_SyncSendPeriodic(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline long ITTLLive2::GetSyncProcessPeriodic ( ) {
    long _result;
    HRESULT _hr = get_SyncProcessPeriodic(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline void ITTLLive2::PutSyncProcessPeriodic ( long pVal ) {
    HRESULT _hr = put_SyncProcessPeriodic(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline long ITTLLive2::GetSyncSendPeriodicInterval ( ) {
    long _result;
    HRESULT _hr = get_SyncSendPeriodicInterval(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline void ITTLLive2::PutSyncSendPeriodicInterval ( long pVal ) {
    HRESULT _hr = put_SyncSendPeriodicInterval(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline long ITTLLive2::GetSyncTimeout ( ) {
    long _result;
    HRESULT _hr = get_SyncTimeout(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline void ITTLLive2::PutSyncTimeout ( long pVal ) {
    HRESULT _hr = put_SyncTimeout(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline ITTLEncoderPtr ITTLLive2::GetMasterEncoder ( ) {
    struct ITTLEncoder * _result;
    HRESULT _hr = get_MasterEncoder(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ITTLEncoderPtr(_result, false);
}

inline long ITTLLive2::GetDebugBuild ( ) {
    long _result;
    HRESULT _hr = get_DebugBuild(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline ITTLChannelPtr ITTLLive2::GetFirstChannel ( ) {
    struct ITTLChannel * _result;
    HRESULT _hr = raw_GetFirstChannel(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ITTLChannelPtr(_result, false);
}

inline ITTLChannelPtr ITTLLive2::GetNextChannel ( ) {
    struct ITTLChannel * _result;
    HRESULT _hr = raw_GetNextChannel(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ITTLChannelPtr(_result, false);
}

inline ITTLEncoderPtr ITTLLive2::GetFirstEncoder ( ) {
    struct ITTLEncoder * _result;
    HRESULT _hr = raw_GetFirstEncoder(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ITTLEncoderPtr(_result, false);
}

inline ITTLEncoderPtr ITTLLive2::GetNextEncoder ( ) {
    struct ITTLEncoder * _result;
    HRESULT _hr = raw_GetNextEncoder(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ITTLEncoderPtr(_result, false);
}

//
// interface ITTLEncoder wrapper method implementations
//

inline float ITTLEncoder::GetBatteryLevelPct ( ) {
    float _result;
    HRESULT _hr = get_BatteryLevelPct(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline _bstr_t ITTLEncoder::GetConnectionName ( ) {
    BSTR _result;
    HRESULT _hr = get_ConnectionName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline enum TTLAPI_CONNECTION_TYPES ITTLEncoder::GetConnectionType ( ) {
    enum TTLAPI_CONNECTION_TYPES _result;
    HRESULT _hr = get_ConnectionType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline long ITTLEncoder::GetPhysicalChannelCount ( ) {
    long _result;
    HRESULT _hr = get_PhysicalChannelCount(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline _bstr_t ITTLEncoder::GetModelName ( ) {
    BSTR _result;
    HRESULT _hr = get_ModelName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline enum TTLAPI_ENCODER_MODEL_TYPES ITTLEncoder::GetModelType ( ) {
    enum TTLAPI_ENCODER_MODEL_TYPES _result;
    HRESULT _hr = get_ModelType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline void ITTLEncoder::PutModelType ( enum TTLAPI_ENCODER_MODEL_TYPES pVal ) {
    HRESULT _hr = put_ModelType(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline long ITTLEncoder::GetFirmwareVersion ( ) {
    long _result;
    HRESULT _hr = get_FirmwareVersion(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline long ITTLEncoder::GetHardwareVersion ( ) {
    long _result;
    HRESULT _hr = get_HardwareVersion(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline enum TTLAPI_PROTOCOL_TYPES ITTLEncoder::GetProtocolType ( ) {
    enum TTLAPI_PROTOCOL_TYPES _result;
    HRESULT _hr = get_ProtocolType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline _bstr_t ITTLEncoder::GetProtocolName ( ) {
    BSTR _result;
    HRESULT _hr = get_ProtocolName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline enum TTLAPI_ENCODER_STATES ITTLEncoder::GetState ( ) {
    enum TTLAPI_ENCODER_STATES _result;
    HRESULT _hr = get_State(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline long ITTLEncoder::GetID ( ) {
    long _result;
    HRESULT _hr = get_ID(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline long ITTLEncoder::GetFirstChannelHND ( ) {
    long _result;
    HRESULT _hr = get_FirstChannelHND(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline void ITTLEncoder::PutFirstChannelHND ( long pVal ) {
    HRESULT _hr = put_FirstChannelHND(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline _bstr_t ITTLEncoder::GetSerialNumber ( ) {
    BSTR _result;
    HRESULT _hr = get_SerialNumber(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline long ITTLEncoder::GetSensorStatus ( ) {
    long _result;
    HRESULT _hr = get_SensorStatus(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline _bstr_t ITTLEncoder::GetTTUSB_SN ( ) {
    BSTR _result;
    HRESULT _hr = get_TTUSB_SN(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline long ITTLEncoder::GetTTUSB_FirmwareVersion ( ) {
    long _result;
    HRESULT _hr = get_TTUSB_FirmwareVersion(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline DATE ITTLEncoder::GetTime ( ) {
    DATE _result;
    HRESULT _hr = get_Time(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline DATE ITTLEncoder::GetTimeAdjustment ( ) {
    DATE _result;
    HRESULT _hr = get_TimeAdjustment(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline enum TTLAPI_PLAYBACK_MODES ITTLEncoder::GetPlaybackMode ( ) {
    enum TTLAPI_PLAYBACK_MODES _result;
    HRESULT _hr = get_PlaybackMode(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline void ITTLEncoder::PutPlaybackMode ( enum TTLAPI_PLAYBACK_MODES pVal ) {
    HRESULT _hr = put_PlaybackMode(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline long ITTLEncoder::GetPlaybackStart ( ) {
    long _result;
    HRESULT _hr = get_PlaybackStart(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline void ITTLEncoder::PutPlaybackStart ( long pVal ) {
    HRESULT _hr = put_PlaybackStart(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline long ITTLEncoder::GetPlaybackEnd ( ) {
    long _result;
    HRESULT _hr = get_PlaybackEnd(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline void ITTLEncoder::PutPlaybackEnd ( long pVal ) {
    HRESULT _hr = put_PlaybackEnd(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline long ITTLEncoder::GetPlaybackPosition ( ) {
    long _result;
    HRESULT _hr = get_PlaybackPosition(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline void ITTLEncoder::PutPlaybackPosition ( long pVal ) {
    HRESULT _hr = put_PlaybackPosition(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline float ITTLEncoder::GetPlaybackSpeed ( ) {
    float _result;
    HRESULT _hr = get_PlaybackSpeed(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline void ITTLEncoder::PutPlaybackSpeed ( float pVal ) {
    HRESULT _hr = put_PlaybackSpeed(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline long ITTLEncoder::GetSwitchState ( ) {
    long _result;
    HRESULT _hr = get_SwitchState(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline void ITTLEncoder::PutSwitchState ( long pVal ) {
    HRESULT _hr = put_SwitchState(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline float ITTLEncoder::GetBatteryLevelVolt ( ) {
    float _result;
    HRESULT _hr = get_BatteryLevelVolt(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline float ITTLEncoder::GetBatteryTimeLeft ( ) {
    float _result;
    HRESULT _hr = get_BatteryTimeLeft(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline long ITTLEncoder::GetEventInputState ( ) {
    long _result;
    HRESULT _hr = get_EventInputState(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline float ITTLEncoder::GetTickRate ( ) {
    float _result;
    HRESULT _hr = get_TickRate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline enum TTLAPI_DECRYPTION_STATES ITTLEncoder::GetDecryptionState ( ) {
    enum TTLAPI_DECRYPTION_STATES _result;
    HRESULT _hr = get_DecryptionState(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline float ITTLEncoder::GetStreamQuality ( ) {
    float _result;
    HRESULT _hr = get_StreamQuality(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline long ITTLEncoder::GetHND ( ) {
    long _result;
    HRESULT _hr = get_HND(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline void ITTLEncoder::PutHND ( long pVal ) {
    HRESULT _hr = put_HND(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline HRESULT ITTLEncoder::CloseConnection ( ) {
    HRESULT _hr = raw_CloseConnection();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT ITTLEncoder::AddChannel ( enum TTLAPI_CHANNELS ePhysicalChannelIndex, long * pliChannelHND ) {
    HRESULT _hr = raw_AddChannel(ePhysicalChannelIndex, pliChannelHND);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT ITTLEncoder::StartRecord ( _bstr_t bstrFilename, enum TTLAPI_RECORDING_MODES eRecordingMode ) {
    HRESULT _hr = raw_StartRecord(bstrFilename, eRecordingMode);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT ITTLEncoder::StopRecord ( ) {
    HRESULT _hr = raw_StopRecord();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT ITTLEncoder::UnlockDecryption ( long liUnlockValue ) {
    HRESULT _hr = raw_UnlockDecryption(liUnlockValue);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline float ITTLEncoder::GetTicksAhead ( ) {
    float _result;
    HRESULT _hr = get_TicksAhead(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline long ITTLEncoder::GetTimeoutPeriod ( ) {
    long _result;
    HRESULT _hr = get_TimeoutPeriod(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline void ITTLEncoder::PutTimeoutPeriod ( long pVal ) {
    HRESULT _hr = put_TimeoutPeriod(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline long ITTLEncoder::GetEventOutputState ( ) {
    long _result;
    HRESULT _hr = get_EventOutputState(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline void ITTLEncoder::PutEventOutputState ( long pVal ) {
    HRESULT _hr = put_EventOutputState(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline HRESULT ITTLEncoder::SendSyncPulse ( ) {
    HRESULT _hr = raw_SendSyncPulse();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}
